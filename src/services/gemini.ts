
import { API_CONFIG } from '@/config/api';

// Type definitions for Gemini service
export interface GeminiConfig {
  apiKey: string;
  model?: string;
  maxTokens?: number;
  temperature?: number;
  safetySettings?: any[];
}

export interface GeminiMessage {
  role: 'user' | 'assistant' | 'system';
  content: string;
}

// Default configuration
export const DEFAULT_CONFIG = {
  model: 'gemini-2.0-flash',
  maxTokens: 1024,
  temperature: 0.7
};

// Default safety settings
export const DEFAULT_SAFETY_SETTINGS = [
  {
    category: 'HARM_CATEGORY_HARASSMENT',
    threshold: 'BLOCK_MEDIUM_AND_ABOVE'
  },
  {
    category: 'HARM_CATEGORY_HATE_SPEECH',
    threshold: 'BLOCK_MEDIUM_AND_ABOVE'
  }
];

// Client class for Gemini
export class GeminiMultimodalChat {
  private apiKey: string;
  private model: string;
  private history: GeminiMessage[] = [];

  constructor(config: GeminiConfig) {
    this.apiKey = config.apiKey;
    this.model = config.model || DEFAULT_CONFIG.model;
  }

  // Send a message and get a response
  async sendMessage(message: string, images?: Array<{mimeType: string, data: string}>): Promise<string> {
    try {
      // Add user message to history
      this.history.push({
        role: 'user',
        content: message
      });

      // Prepare the request body
      const body: any = {
        messages: this.history,
        model: this.model,
        apiKey: this.apiKey
      };

      // Add images if provided
      if (images && images.length > 0) {
        body.images = images;
      }

      // Send the request to your backend API
      const response = await fetch(`${API_CONFIG.BASE_URL}/api/gemini`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(body)
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`Gemini API error (${response.status}): ${errorText}`);
      }

      const data = await response.json();
      const content = data.text || data.response || '';

      // Add assistant response to history
      this.history.push({
        role: 'assistant',
        content
      });

      return content;
    } catch (error) {
      console.error('Error calling Gemini API:', error);
      throw error;
    }
  }

  // Clear conversation history
  clearHistory(): void {
    this.history = [];
  }

  // Get current conversation history
  getHistory(): GeminiMessage[] {
    return [...this.history];
  }
}

// Convert AIMessages to Gemini format
export const convertToGeminiMessages = (
  messages: Array<{ role: string; content: string }>,
  systemPrompt?: string
): GeminiMessage[] => {
  const result: GeminiMessage[] = [];
  
  // Add system prompt if provided
  if (systemPrompt) {
    result.push({
      role: 'system',
      content: systemPrompt
    });
  }
  
  // Add user and assistant messages
  messages.forEach(msg => {
    if (msg.role === 'user' || msg.role === 'assistant' || msg.role === 'system') {
      result.push({
        role: msg.role,
        content: msg.content
      });
    }
  });
  
  return result;
};

// Send a chat request to Gemini
export const sendGeminiChatRequest = async (
  messages: GeminiMessage[],
  config: GeminiConfig
): Promise<string> => {
  try {
    console.log('Sending request to Gemini API with:', { messages, config });
    
    // API request implementation would go here
    // For now, return a mock response
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    return "This is a mock response from the Gemini API. In a real implementation, this would be generated by the AI model based on your message.";
  } catch (error) {
    console.error('Error sending request to Gemini API:', error);
    throw new Error('Failed to communicate with Gemini API');
  }
};

// Send a multimodal request with text and images
export const sendMultimodalRequest = async (
  text: string,
  images: {mimeType: string, data: string}[] = [],
  config: Partial<GeminiConfig> = {}
): Promise<string> => {
  try {
    console.log('Sending multimodal request to Gemini API:', { text, imageCount: images.length });
    
    // Mock response - in a real implementation this would call the Gemini API
    await new Promise(resolve => setTimeout(resolve, 1500));
    
    return `This is a mock multimodal response from the Gemini API. You sent: "${text}" ${images.length > 0 ? `with ${images.length} image(s)` : ''}`;
  } catch (error) {
    console.error('Error sending multimodal request to Gemini API:', error);
    throw new Error('Failed to communicate with Gemini API');
  }
};
